@page "/"

<p>@GregorianToDate(calendarType.Attic, new DateTime(2024, 12, 31))</p>
<p>@GregorianToDate(calendarType.Attic, new DateTime(2025, 6, 21))</p>
<p>@GregorianToDate(calendarType.Attic, new DateTime(2025, 12, 12))</p>
<p>@GregorianToDate(calendarType.Attic, new DateTime(2025, 12, 20))</p>
<p>@GregorianToDate(calendarType.Attic, new DateTime(2025, 12, 21))</p>
<p>@GregorianToDate(calendarType.Attic, new DateTime(2025, 12, 22))</p>

<p style="text-align:center; position:absolute; width: 100%">@monthName</p>
<p style="position:absolute; width: 33%; margin-right: 33%" @onclick="() => ChangeDate(months:-1)">◀</p>
<p style="text-align:right; position:absolute; width: 33%; margin-left: 67%" @onclick="() => ChangeDate(months:1)">▶</p>

<ul class="days">
    @GetDayListHtml()
</ul>

<style>
    .days {
        background: #eee;
        width: 100%;
        height: 100vh;
        padding: 0px;
        line-height: 0;
        border: solid #aaa 1px;
    }

    .days li {
        list-style-type: none;
        display: inline-block;
        width: calc(100% / @rowSize);
        height: calc(100% / @(Math.Max(Math.Ceiling((float)daysInMonth / rowSize), minRows)));
        text-align: center;
        font-size: 12px;
        color: #777;
        border: solid #aaa 1px;
    }
    .dayContent{
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
    }

    .days li.title{
        aspect-ratio: .1;
    }
</style>

@code {
    protected override async Task OnInitializedAsync()
    {
        RefreshYearData();
    }

    enum calendarType
    {
        Gregorian,
        Attic
    }
    private calendarType calendar = calendarType.Attic;

    private int rowSize = 7;
    private int minRows = 5;
    private string monthName;

    private int daysInMonth = 30;
    private int monthsInYear = 12;

    private int day = 1;
    private int month = DateTime.Now.Month;
    private int year = 2024;
    private DateTime firstOfTheMonthInGregorian;
    private DateTime firstOfTheYearInGregorian;

    private bool useLowPrecisionMoonPhaseCalculation;

    private void RefreshYearData()
    {
        var yearData = GetYearData(year);
        monthsInYear = yearData.Item1;
        rowSize = yearData.Item2;
        minRows = yearData.Item3;
        firstOfTheYearInGregorian = yearData.Item4;
        RefreshMonthData();
    }
    private void RefreshMonthData()
    {
        var monthData = GetMonthData(month, year);
        monthName = monthData.Item1;
        daysInMonth = monthData.Item2;
        firstOfTheMonthInGregorian = monthData.Item3;
    }
    private ValueTuple<int, int, int, DateTime> GetYearData(int year)
    {
        var monthsInYear = 12;
        var rowSize = 7;
        var minRows = 5;
        var firstOfTheYearInGregorian = new DateTime();

        if (calendar == calendarType.Gregorian)
        {
            monthsInYear = 12;
            rowSize = 7;
            minRows = 5;
        }
        else if (calendar == calendarType.Attic)
        {

        }
        return new(monthsInYear, rowSize, minRows, firstOfTheYearInGregorian);
    }
    private ValueTuple<string, int, DateTime> GetMonthData(int month, int year)
    {
        var monthName = "Invalid month";
        var daysInMonth = 30;
        DateTime firstOfTheMonthInGregorian = new();
        if (calendar == calendarType.Gregorian)
        {
            switch (month)
            {
                case 1: monthName = "January"; daysInMonth = 31; break;
                case 2: monthName = "February"; if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) { daysInMonth = 29; } else { daysInMonth = 28; } break;
                case 3: monthName = "March"; daysInMonth = 31; break;
                case 4: monthName = "April"; daysInMonth = 30; break;
                case 5: monthName = "May"; daysInMonth = 31; break;
                case 6: monthName = "June"; daysInMonth = 30; break;
                case 7: monthName = "July"; daysInMonth = 31; break;
                case 8: monthName = "August"; daysInMonth = 31; break;
                case 9: monthName = "September"; daysInMonth = 30; break;
                case 10: monthName = "October"; daysInMonth = 31; break;
                case 11: monthName = "November"; daysInMonth = 30; break;
                case 12: monthName = "December"; daysInMonth = 31; break;
                default: monthName = "Invalid month"; daysInMonth = 100; break;
            };
            firstOfTheMonthInGregorian = new(year, month, 1);
        }
        else if (calendar == calendarType.Attic)
        {
            monthName = month switch
            {
                1 => "Ἑκατομβαιών",
                2 => "Μεταγειτνιών",
                3 => "Βοηδρομιών",
                4 => "Πυανεψιών",
                5 => "Μαιμακτηριών",
                6 => "Ποσειδεών",
                7 => "Γαμηλιών",
                8 => "Ἀνθεστηριών",
                9 => "Ἐλαφηβολιών",
                10 => "Μουνυχιών",
                11 => "Θαργηλιών",
                12 => "Σκιροφοριών",
                13 => "Πυανεψιών",
                _ => "Invalid month"
            };
        }
        return new(monthName, daysInMonth, firstOfTheMonthInGregorian);
    }

    private DateTime DateToGregorian(calendarType calendar, ValueTuple<int, int, double> date)
    {
        if (calendar == calendarType.Attic)
        {

        }
        else
        {
            return new DateTime(date.Item1, date.Item2, 1).AddDays(date.Item3 - 1);
        }
        return default;
    }
    //      ValueTuple<year, month, day>
    private /*ValueTuple<int, int, double>*/ string GregorianToDate(calendarType calendar, DateTime date)
    {
        if (calendar == calendarType.Attic)
        {
            var d = GetClosestSummerSolstice(date);
            var nextFirstOfTheYearBasedOnSolstice = new DateTime(d.Year, d.Month, d.Day, 0, 0, 0);
            if (d.Hour > 0) nextFirstOfTheYearBasedOnSolstice = nextFirstOfTheYearBasedOnSolstice.AddDays(1);

            d = GetClosestSummerSolstice(date, false); // for year expressed in greek years, GetClosestSummerSolstice(new DateTime(gregorianYear, 1, 1))
            var firstOfTheYearInGregorian = new DateTime(d.Year, d.Month, d.Day, 0, 0, 0);
            if (d.Hour > 0) firstOfTheYearInGregorian = firstOfTheYearInGregorian.AddDays(1);
            firstOfTheYearInGregorian = GetClosestMoonPhase(firstOfTheYearInGregorian, out var k, true);

            var monthsInYear = 0;
            var monthBeginnings = new List<DateTime>();
            var newMoon = firstOfTheYearInGregorian;
            while (newMoon <= nextFirstOfTheYearBasedOnSolstice)
            {
                monthBeginnings.Add(newMoon);
                k++;
                newMoon = GetDateForMoonPhase(k);
                monthsInYear++;
            }
            var firstOfTheNextYear = GetDateForMoonPhase(k + 1);


            d = monthBeginnings.Where(element => element <= date).Max();
            var firstOfTheMonthInGregorian = new DateTime(d.Year, d.Month, d.Day, 0, 0, 0);
            if (d.Hour > 0) firstOfTheMonthInGregorian = firstOfTheMonthInGregorian.AddDays(1);
                    
            var month = monthBeginnings.IndexOf(d) + 1; // +1 beacuse of lists starting at 0
            var day = (int)Math.Ceiling((date - firstOfTheMonthInGregorian).TotalDays) + 1; // +1 because days start at 1

            return date + " returns " + new ValueTuple<int, int, double>(date.Year, month, day).ToString() + " : " + firstOfTheMonthInGregorian + " : " + d;
            // daysInMonth = (int)(firstOfTheNextMonth - firstOfTheMonthInGregorian).TotalDays;
            // monthsInYear
        }
        else
        {
            return new ValueTuple<int, int, double>(date.Year, date.Month, date.Day + date.Hour / 24 + date.Minute / 1440).ToString();
        }
    }

    private void ChangeDate(int days = 0, int months = 0, int years = 0)
    {
        day += days;
        month += months;
        year += years;

        while (month > monthsInYear)
        {
            year++;
            month -= monthsInYear;
        }
        while (month < 1)
        {
            year--;
            month += monthsInYear;
        }

        while (day > daysInMonth)
        {
            month++;
            day -= daysInMonth;
        }
        while (day < 1)
        {
            month--;
            day += daysInMonth;
        }

        RefreshYearData();
    }

    private MarkupString GetDayListHtml()
    {
        if (year < 1000 || year > 3000) // convert the year to gregorian before checking
        {
            return (MarkupString)"Sorry, but the calendar only works in 1000-3000 Gregorian years";
        }

        var html = "";
        for (int i = 1; i < daysInMonth + 1; i++)
        {
            html += $"<li><div class=\"dayContent\">{i}({firstOfTheMonthInGregorian.Day + i - 1})</div></li>";
        }
        var emptyBoxCount = Math.Max(minRows * rowSize - daysInMonth, 0);
        if ((daysInMonth + emptyBoxCount) % rowSize != 0)
        {
            emptyBoxCount += rowSize - (daysInMonth + emptyBoxCount) % rowSize;
        }
        for (int i = 0; i < emptyBoxCount; i++)
        {
            html += "<li><div class=\"dayContent\">⠀</div></li>";
        }

        return (MarkupString)html;
    }

    private double GregorianToJD(ValueTuple<int, int, double> date)
    {
        var years = date.Item1;
        var months = date.Item2;
        var days = date.Item3;
        // Chapter 7, pdf page 69, slightly imprecise for far years, while it appearently shouldn't

        if (months <= 2)
        {
            years--;
            months += 12;
        }
        var A = (int)Math.Truncate((float)years / 100);
        var B = 0;
        if (years >= 1582 && months >= 10 && days >= 15.5) // when Gregorian was created
        {
            B = 2 - A + (int)Math.Truncate((float)A / 4);
        }
        var JD = Math.Truncate(365.25 * (years + 4716)) + Math.Truncate(30.6001 * (months + 1)) + days + B - 1524.5;
        return JD;
    }
    private ValueTuple<int, int, double> JDToGregorian(double JD)
    {
        // Chapter 7, pdf page 71

        JD += .5;
        var Z = Math.Truncate(JD);
        var F = JD - Z;
        var A = Z;
        if (Z >= 2299161) // or 2291161??
        {
            var α = Math.Truncate((Z - 1867216.25) / 36524.25);
            A = Z + 1 + α - Math.Truncate(α / 4);
        }
        var B = A + 1524;
        var C = Math.Truncate((B - 122.1) / 365.25);
        var D = Math.Truncate(365.25 * C);
        var E = Math.Truncate((B - D) / 30.6001);
        var days = B - D - Math.Truncate(30.6001 * E) + F;
        var months = E - 1;
        if (E >= 14)
        {
            months = E - 13;
        }
        var years = C - 4716;
        if (months <= 2)
        {
            years = C - 4715;
        }
        return new((int)years, (int)months, days);
    }
    private DateTime JDToGregorian(double JD, bool useDateTime)
    {
        var tuple = JDToGregorian(JD);
        return new DateTime(tuple.Item1, tuple.Item2, 1).AddDays(tuple.Item3 - 1);
    }

    private DateTime GetDateForMoonPhase(double k)
    {
        var T = k / 1236.85;
        var JDE = 2451550.09766 + 29.530588861 * k + 0.00015437 * T*T - 0.00000015 * T*T*T + 0.00000000073 * T*T*T*T;
        if (useLowPrecisionMoonPhaseCalculation)
        {
            return JDToGregorian(JDE, true);
        }
        var E = 1 - 0.002516 * T - 0.0000074 * T*T;
        var M = (2.5534 + 29.10535670 * k - 0.0000014 * T*T - 0.00000011 * T*T*T) * Math.PI / 180;
        var Mp = (201.5643 + 385.81693528 * k + 0.0107582 * T*T + 0.00001238 * T*T*T - 0.000000058 * T*T*T*T) * Math.PI / 180;
        var F = (160.7108 + 390.67050284 * k - 0.0016118 * T*T - 0.00000227 * T*T*T + 0.000000011 * T*T*T*T) * Math.PI / 180;
        var Ω = (124.7746 - 1.56375588 * k + 0.0020672 * T*T + 0.00000215 * T*T*T) * Math.PI / 180;

        var A1 = (299.77 + 0.107408 * k - 0.009173 * T*T) * Math.PI / 180;
        var A2 = (251.88 + 0.016321 * k) * Math.PI / 180;
        var A3 = (251.83 + 26.651886 * k) * Math.PI / 180;
        var A4 = (349.42 + 36.412478 * k) * Math.PI / 180;
        var A5 = (84.66 + 18.206239 * k) * Math.PI / 180;
        var A6 = (141.74 + 53.303771 * k) * Math.PI / 180;
        var A7 = (207.14 + 2.453732 * k) * Math.PI / 180;
        var A8 = (154.84 + 7.306860 * k) * Math.PI / 180;
        var A9 = (34.52 + 27.261239 * k) * Math.PI / 180;
        var A10 = (207.19 + 0.121824 * k) * Math.PI / 180;
        var A11 = (291.34 + 1.844379 * k) * Math.PI / 180;
        var A12 = (161.72 + 24.198154 * k) * Math.PI / 180;
        var A13 = (239.56 + 25.513099 * k) * Math.PI / 180;
        var A14 = (331.55 + 3.592518 * k) * Math.PI / 180;
        if (Math.Round(k) == k)
        {
            JDE += -0.4072 * Math.Sin(Mp) + 0.17241 * E * Math.Sin(M) + 0.01608 * Math.Sin(2 * Mp) + 0.01039 * Math.Sin(2 * F) + 0.00739 * E * Math.Sin(Mp - M) - 0.00514 * E * Math.Sin(Mp + M) + 0.00208 * E*E * Math.Sin(2 * M) - 0.00111 * Math.Sin(Mp - 2 * F) - 0.00057 * Math.Sin(Mp + 2 * F) + 0.00056 * E * Math.Sin(2 * Mp + M) - 0.00042 * Math.Sin(3 * Mp) + 0.00042 * E * Math.Sin(M + 2 * F) + 0.00038 * E * Math.Sin(M - 2 * F) - 0.00024 * E * Math.Sin(2 * Mp - M) - 0.00017 * Math.Sin(Ω) - 0.00007 * Math.Sin(Mp + 2 * M) + 0.00004 * Math.Sin(2 * Mp - 2 * F) + 0.00004 * Math.Sin(3 * M) + 0.00003 * Math.Sin(Mp + M - 2 * F) + 0.00003 * Math.Sin(2 * Mp + 2 * F) - 0.00003 * Math.Sin(Mp + M + 2 * F) + 0.00003 * Math.Sin(Mp - M + 2 * F) - 0.00002 * Math.Sin(Mp - M - 2 * F) - 0.00002 * Math.Sin(3 * Mp + M) + 0.00002 * Math.Sin(4 * Mp);
        }
        else if (Math.Ceiling(k) - .5 == k)
        {
            JDE += -0.40614 * Math.Sin(Mp) + 0.17302 * E * Math.Sin(M) + 0.01614 * Math.Sin(2 * Mp) + 0.01043 * Math.Sin(2 * F) + 0.00734 * E * Math.Sin(Mp - M) - 0.00515 * E * Math.Sin(Mp + M) + 0.00209 * E*E * Math.Sin(2 * M) - 0.00111 * Math.Sin(Mp - 2 * F) - 0.00057 * Math.Sin(Mp + 2 * F) + 0.00056 * E * Math.Sin(2 * Mp + M) - 0.00042 * Math.Sin(3 * Mp) + 0.00042 * E * Math.Sin(M + 2 * F) + 0.00038 * E * Math.Sin(M - 2 * F) - 0.00024 * E * Math.Sin(2 * Mp - M) - 0.00017 * Math.Sin(Ω) - 0.00007 * Math.Sin(Mp + 2 * M) + 0.00004 * Math.Sin(2 * Mp - 2 * F) + 0.00004 * Math.Sin(3 * M) + 0.00003 * Math.Sin(Mp + M - 2 * F) + 0.00003 * Math.Sin(2 * Mp + 2 * F) - 0.00003 * Math.Sin(Mp + M + 2 * F) + 0.00003 * Math.Sin(Mp - M + 2 * F) - 0.00002 * Math.Sin(Mp - M - 2 * F) - 0.00002 * Math.Sin(3 * Mp + M) + 0.00002 * Math.Sin(4 * Mp);
        }
        else
        {

        }
        JDE += (325 * Math.Sin(A1) + 165 * Math.Sin(A2) + 164 * Math.Sin(A3) + 126 * Math.Sin(A4) + 110 * Math.Sin(A5) + 62 * Math.Sin(A6) + 60 * Math.Sin(A7) + 56 * Math.Sin(A8) + 47 * Math.Sin(A9) + 42 * Math.Sin(A10) + 40 * Math.Sin(A11) + 37 * Math.Sin(A12) + 35 * Math.Sin(A13) + 23 * Math.Sin(A14)) / 1000000;
        return JDToGregorian(JDE, true);
    }
    private DateTime GetSummerSolsticeForGregorianYear(int year)
    {
        var Y = ((float)year - 2000) / 1000;
        var JDE0 = 2451716.56767 + 365241.62603 * Y + 0.00325 * Y*Y + 0.00888 * Y*Y*Y - 0.00030 * Y*Y*Y*Y;
        var T = (JDE0 - 2451545) / 36525;
        var W = 35999.373 * T - 2.47;
        var Δλ = 1 + 0.0334 * Math.Cos(W * Math.PI / 180) + 0.0007 * Math.Cos(W * Math.PI / 90);
        var S = ﻿485 * Math.Cos((324.96 + 1934.136 * T) * Math.PI / 180) + 45 * Math.Cos((247.54 + 29929.562 * T) * Math.PI / 180) + 203 * Math.Cos((337.23 + 32964.467 * T) * Math.PI / 180) + 44 * Math.Cos((325.15 + 31555.956 * T) * Math.PI / 180) + 199 * Math.Cos((342.08 + 20.186 * T) * Math.PI / 180) + 29 * Math.Cos((60.93 + 4443.417 * T) * Math.PI / 180) + 182 * Math.Cos((27.85 + 445267.112 * T) * Math.PI / 180) + 18 * Math.Cos((155.12 + 67555.328 * T) * Math.PI / 180) + 156 * Math.Cos((73.14 + 45036.886 * T) * Math.PI / 180) + 17 * Math.Cos((288.79 + 4562.452 * T) * Math.PI / 180) + 136 * Math.Cos((171.52 + 22518.443 * T) * Math.PI / 180) + 16 * Math.Cos((198.04 + 62894.029 * T) * Math.PI / 180) + 77 * Math.Cos((222.54 + 65928.934 * T) * Math.PI / 180) + 14 * Math.Cos((199.76 + 31436.921 * T) * Math.PI / 180) + 74 * Math.Cos((296.72 + 3034.906 * T) * Math.PI / 180) + 12 * Math.Cos((95.39 + 14577.848 * T) * Math.PI / 180) + 70 * Math.Cos((243.58 + 9037.513 * T) * Math.PI / 180) + 12 * Math.Cos((287.11 + 31931.756 * T) * Math.PI / 180) + 58 * Math.Cos((119.81 + 33718.147 * T) * Math.PI / 180) + 12 * Math.Cos((320.81 + 34777.259 * T) * Math.PI / 180) + 52 * Math.Cos((297.17 + 150.678 * T) * Math.PI / 180) + 9 * Math.Cos((227.73 + 1222.114 * T) * Math.PI / 180) + 50 * Math.Cos((21.02 + 2281.226 * T) * Math.PI / 180) + 8 * Math.Cos((15.45 + 16859.074 * T) * Math.PI / 180);
        var JDE = JDE0 + (0.00001 * S) / Δλ;
        var dateTriplet = JDToGregorian(JDE);
        return new DateTime(dateTriplet.Item1, dateTriplet.Item2, 1).AddDays(dateTriplet.Item3 - 1);
    }
    private DateTime GetClosestMoonPhase(DateTime dateTime, bool isForward = true, double phase = 0)
    {
        return GetClosestMoonPhase(dateTime, out var a, isForward, phase);
    }
    private DateTime GetClosestMoonPhase(DateTime dateTime, out double finalK, bool isForward = true, double phase = 0)
    {
        var k = (dateTime.Year - 2000) * 12.3685 + dateTime.Month;
        if (k > 0)
        {
            k = Math.Ceiling(k);
        }
        else
        {
            k = Math.Floor(k);
        }
        k += phase;
        var kMoon = GetDateForMoonPhase(k);
        if ((dateTime - kMoon).TotalDays < 30) // less than maximum cycle length difference
        {
            goto isCloseEnough;
        }
        k += Math.Floor((dateTime - kMoon).TotalDays / 30) * (dateTime > kMoon ? 1 : -1); // minimum cycles off
        kMoon = GetDateForMoonPhase(k);
        while ((dateTime - kMoon).TotalDays >= 30) // just to make sure, since I got no clue if my logic is right
        {
            k += (dateTime > kMoon ? 1 : -1);
            kMoon = GetDateForMoonPhase(k);
        }

    isCloseEnough:
        DateTime[] moons = new DateTime[3] { kMoon,
        GetDateForMoonPhase(k - 1),
        GetDateForMoonPhase(k + 1) };

        var moon = moons.Where(element => isForward ? (element > dateTime) : (element < dateTime)).OrderBy(element => Math.Max((element - dateTime).TotalDays, (dateTime - element).TotalDays)).First();
        finalK = Array.IndexOf(moons, moon) switch
        {
            0 => k,
            1 => k - 1,
            _ => k + 1
        };
        return moon;
    }
    private DateTime GetClosestSummerSolstice(DateTime dateTime, bool isForward = true)
    {
        DateTime[] solstices = new DateTime[3] { GetSummerSolsticeForGregorianYear(dateTime.Year),
        GetSummerSolsticeForGregorianYear(dateTime.Year - 1),
        GetSummerSolsticeForGregorianYear(dateTime.Year + 1) };

        return solstices.Where(element => isForward ? (element > dateTime) : (element < dateTime)).OrderBy(element => Math.Max((element - dateTime).TotalDays, (dateTime - element).TotalDays)).First();
    }
}
