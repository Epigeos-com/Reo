@page "/"

<p>@GregorianToDate(CalendarType.Attic, new DateTime(2024, 6, 3)) : @GetDateInfo(CalendarType.Attic, new DateTime(2024, 6, 3)).monthName</p>
<p>@GregorianToDate(CalendarType.Attic, new DateTime(2024, 6, 20)) : @GetDateInfo(CalendarType.Attic, new DateTime(2024, 6, 20)).monthName</p>
<p>@GregorianToDate(CalendarType.Attic, new DateTime(2022, 12, 2)) : @GetDateInfo(CalendarType.Attic, new DateTime(2022, 12, 2)).monthName</p>
<p>@GregorianToDate(CalendarType.Attic, new DateTime(2022, 12, 31)) : @GetDateInfo(CalendarType.Attic, new DateTime(2022, 12, 31)).monthName</p>
<p>@currentCalendarData.yearName</p>

<p style="text-align:center; position:absolute; width: 100%">@currentCalendarData.monthName</p>
<p style="position:absolute; width: 33%; margin-right: 33%" @onclick="() => ChangeDate(CalendarType.Gregorian, months:-1)">◀</p>
<p style="text-align:right; position:absolute; width: 33%; margin-left: 67%" @onclick="() => ChangeDate(CalendarType.Gregorian, months:1)">▶</p>

<ul class="days">
    @GetDayListHtml()
</ul>

<style>
    .days {
        background: #eee;
        width: 100%;
        height: 100vh;
        padding: 0px;
        line-height: 0;
        border: solid #aaa 1px;
    }

    .days li {
        list-style-type: none;
        display: inline-block;
        width: calc(100% / @currentCalendarData.rowSize);
        height: calc(100% / @(Math.Max(Math.Ceiling((float)currentCalendarData.daysInMonth / currentCalendarData.rowSize), currentCalendarData.minRows)));
        text-align: center;
        font-size: 12px;
        color: #777;
        border: solid #aaa 1px;
    }
    .dayContent{
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
    }

    .days li.title{
        aspect-ratio: .1;
    }
</style>

@code {
    protected override async Task OnInitializedAsync()
    {
        RefreshCalendarData();
    }

    enum CalendarType
    {
        Gregorian,
        Attic
    }
    private CalendarType calendar = CalendarType.Attic;

    private DateInfo currentCalendarData = new();
    private DateTime currentGregorianDate = new(2024, 3, 22, 0, 0, 0);

    private bool useLowPrecisionMoonPhaseCalculation;
    private double longitude;
    private double latitude;
    // Attic
    private int monthToDoubleInAttic = 5;
    private string doubledMonthNameFormattingInAttic = "{originalName} II";
    private string yearNameInAttic = "O{olympiad} Y{year}";

    private void RefreshCalendarData()
    {
        currentCalendarData = GetDateInfo(calendar, currentGregorianDate);
    }
    struct DateInfo
    {
        public ValueTuple<int, int, double> date;
        public DateTime firstOfTheYearInGregorian;
        public DateTime firstOfTheMonthInGregorian;
        public int monthsInYear = 12;
        public int daysInMonth = 30;
        public int rowSize = 7;
        public int minRows = 5;
        public string yearName = "2024";
        public string monthName = "Invalid month";

        public DateInfo(ValueTuple<int, int, double> date, DateTime firstOfTheYearInGregorian, DateTime firstOfTheMonthInGregorian, int monthsInYear, int daysInMonth, int rowSize, int minRows, string yearName, string monthName) : this()
        {
            this.date = date;
            this.firstOfTheYearInGregorian = firstOfTheYearInGregorian;
            this.firstOfTheMonthInGregorian = firstOfTheMonthInGregorian;
            this.monthsInYear = monthsInYear;
            this.daysInMonth = daysInMonth;
            this.rowSize = rowSize;
            this.minRows = minRows;
            this.yearName = yearName;
            this.monthName = monthName;
        }
        public DateInfo(DateTime firstOfTheYearInGregorian, DateTime firstOfTheMonthInGregorian, int monthsInYear, int daysInMonth, int rowSize, int minRows, string yearName, string monthName) : this()
        {
            this.firstOfTheYearInGregorian = firstOfTheYearInGregorian;
            this.firstOfTheMonthInGregorian = firstOfTheMonthInGregorian;
            this.monthsInYear = monthsInYear;
            this.daysInMonth = daysInMonth;
            this.rowSize = rowSize;
            this.minRows = minRows;
            this.yearName = yearName;
            this.monthName = monthName;
        }
        public bool ContainsDate()
        {
            return date == default;
        }
    }
    private DateInfo GetDateInfo(CalendarType calendar, DateTime gregorianDate)
    {
        ValueTuple<int, int, double> outputDate = default;
        DateTime firstOfTheYearInGregorian = default;
        DateTime firstOfTheMonthInGregorian = default;
        var monthsInYear = 12;
        var daysInMonth = 30;
        var rowSize = 7;
        var minRows = 5;
        var yearName = "2024";
        var monthName = "Invalid month";

        var date = gregorianDate;
        if (calendar == CalendarType.Gregorian)
        {
            firstOfTheYearInGregorian = new(date.Year, 1, 1);
            firstOfTheMonthInGregorian = new(date.Year, date.Month, 1);

            outputDate = new(date.Year, date.Month, date.Day + date.Hour / 24 + date.Minute / 1440);

            monthsInYear = 12;
            rowSize = 7;
            minRows = 5;

            yearName = date.Year.ToString();
            switch (date.Month)
            {
                case 1: monthName = "January"; daysInMonth = 31; break;
                case 2: monthName = "February"; if ((date.Year % 4 == 0 && date.Year % 100 != 0) || date.Year % 400 == 0) { daysInMonth = 29; } else { daysInMonth = 28; } break;
                case 3: monthName = "March"; daysInMonth = 31; break;
                case 4: monthName = "April"; daysInMonth = 30; break;
                case 5: monthName = "May"; daysInMonth = 31; break;
                case 6: monthName = "June"; daysInMonth = 30; break;
                case 7: monthName = "July"; daysInMonth = 31; break;
                case 8: monthName = "August"; daysInMonth = 31; break;
                case 9: monthName = "September"; daysInMonth = 30; break;
                case 10: monthName = "October"; daysInMonth = 31; break;
                case 11: monthName = "November"; daysInMonth = 30; break;
                case 12: monthName = "December"; daysInMonth = 31; break;
                default: monthName = "Invalid month"; daysInMonth = 100; break;
            };
        }
        else if (calendar == CalendarType.Attic)
        {
            firstOfTheYearInGregorian = FloorDateTime(GetClosestSummerSolstice(date, out var year, false));
            firstOfTheYearInGregorian = GetClosestMoonPhase(firstOfTheYearInGregorian, out var k, true);

            var nextFirstOfTheYearBasedOnSolstice = FloorDateTime(GetClosestSummerSolstice(date));

            monthsInYear = 0;
            var newMoon = firstOfTheYearInGregorian;
            var monthBeginnings = new List<DateTime>();
            while (newMoon <= nextFirstOfTheYearBasedOnSolstice)
            {
                monthBeginnings.Add(newMoon);
                k++;
                newMoon = GetDateForMoonPhase(k);
                monthsInYear++;
            }
            var firstOfTheNextYear = GetDateForMoonPhase(k);

            var unroundedFirstOfTheMonth = monthBeginnings.Where(element => element <= date).Max();
            firstOfTheMonthInGregorian = FloorDateTime(unroundedFirstOfTheMonth);

            year += 779;
            var olympiad = Math.Floor((double)year / 4);
            yearName = yearNameInAttic.Replace("{olympiad}", olympiad.ToString()).Replace("{year}", ((double)year - 4 * olympiad + 1).ToString()).Replace("{totalYear}", year.ToString());
            var month = monthBeginnings.IndexOf(unroundedFirstOfTheMonth) + 1; // +1 beacuse of lists starting at 0
            var day = (int)Math.Ceiling((date - firstOfTheMonthInGregorian).TotalDays) + 1; // +1 because days start at 1
            outputDate = new(year, month, day);

            var firstOfTheNextMonth = new DateTime();
            try
            {
                firstOfTheNextMonth = FloorDateTime(monthBeginnings[month]);
            }
            catch
            {
                firstOfTheNextMonth = FloorDateTime(firstOfTheNextYear);
            }
            daysInMonth = (int)(firstOfTheNextMonth - firstOfTheMonthInGregorian).TotalDays;

            List<string> monthNames = new() { "Ἑκατομβαιών", "Μεταγειτνιών", "Βοηδρομιών", "Πυανεψιών", "Μαιμακτηριών", "Ποσειδεών", "Γαμηλιών", "Ἀνθεστηριών", "Ἐλαφηβολιών", "Μουνυχιών", "Θαργηλιών", "Σκιροφοριών" };
            if (monthsInYear == 13) monthNames.Insert(monthToDoubleInAttic + 1, doubledMonthNameFormattingInAttic.Replace("{originalName}", monthNames[monthToDoubleInAttic]));
            monthName = monthNames[month - 1];
        }

        return new(outputDate, firstOfTheYearInGregorian, firstOfTheMonthInGregorian, monthsInYear, daysInMonth, rowSize, minRows, yearName, monthName);
    }

    private DateTime DateToGregorian(CalendarType calendar, ValueTuple<int, int, double> date)
    {
        if (calendar == CalendarType.Attic)
        {

        }
        else
        {
            return new DateTime(date.Item1, date.Item2, 1).AddDays(date.Item3 - 1);
        }
        return default;
    }
    //      ValueTuple<year, month, day>
    private ValueTuple<int, int, double> GregorianToDate(CalendarType calendar, DateTime date)
    {
        if (calendar == CalendarType.Attic)
        {
            var dateInfo = GetDateInfo(calendar, date);
            return dateInfo.date;
        }
        else
        {
            return new ValueTuple<int, int, double>(date.Year, date.Month, date.Day + date.Hour / 24 + date.Minute / 1440);
        }
    }

    private void ChangeDate(CalendarType calendar, int days = 0, int months = 0, int years = 0)
    {
        if (calendar == CalendarType.Gregorian)
        {
            currentGregorianDate = currentGregorianDate.AddYears(years).AddMonths(months).AddDays(days);
        }
        else if (calendar == CalendarType.Attic)
        {
            /*dayGregorian += days;
            monthGregorian += months;
            yearGregorian += years;

            while (monthGregorian > monthsInYear)
            {
                yearGregorian++;
                monthGregorian -= monthsInYear;
            }
            while (monthGregorian < 1)
            {
                yearGregorian--;
                monthGregorian += monthsInYear;
            }

            while (dayGregorian > daysInMonth)
            {
                monthGregorian++;
                dayGregorian -= daysInMonth;
            }
            while (dayGregorian < 1)
            {
                monthGregorian--;
                dayGregorian += daysInMonth;
            }*/
        }

        RefreshCalendarData();
    }

    private MarkupString GetDayListHtml()
    {
        if (currentGregorianDate.Year < 1000 || currentGregorianDate.Year > 3000)
        {
            return (MarkupString)"Sorry, but the calendar only works in 1000-3000 Gregorian years";
        }

        var html = "";
        for (int i = 1; i < currentCalendarData.daysInMonth + 1; i++)
        {
            html += $"<li><div class=\"dayContent\">{i}({currentCalendarData.firstOfTheMonthInGregorian.Day + i - 1})</div></li>";
        }
        var emptyBoxCount = Math.Max(currentCalendarData.minRows * currentCalendarData.rowSize - currentCalendarData.daysInMonth, 0);
        if ((currentCalendarData.daysInMonth + emptyBoxCount) % currentCalendarData.rowSize != 0)
        {
            emptyBoxCount += currentCalendarData.rowSize - (currentCalendarData.daysInMonth + emptyBoxCount) % currentCalendarData.rowSize;
        }
        for (int i = 0; i < emptyBoxCount; i++)
        {
            html += "<li><div class=\"dayContent\">⠀</div></li>";
        }

        return (MarkupString)html;
    }

    private DateTime FloorDateTime(DateTime date)
    {
        var output = new DateTime(date.Year, date.Month, date.Day, 0, 0, 0);
        if (date.Hour > 0) output = output.AddDays(1);
        return output;
    }

    private double GregorianToJD(ValueTuple<int, int, double> date)
    {
        var years = date.Item1;
        var months = date.Item2;
        var days = date.Item3;
        // Chapter 7, pdf page 69, slightly imprecise for far years, while it appearently shouldn't

        if (months <= 2)
        {
            years--;
            months += 12;
        }
        var A = (int)Math.Truncate((float)years / 100);
        var B = 0;
        if (years >= 1582 && months >= 10 && days >= 15.5) // when Gregorian was created
        {
            B = 2 - A + (int)Math.Truncate((float)A / 4);
        }
        var JD = Math.Truncate(365.25 * (years + 4716)) + Math.Truncate(30.6001 * (months + 1)) + days + B - 1524.5;
        return JD;
    }
    private ValueTuple<int, int, double> JDToGregorian(double JD)
    {
        // Chapter 7, pdf page 71

        JD += .5;
        var Z = Math.Truncate(JD);
        var F = JD - Z;
        var A = Z;
        if (Z >= 2299161) // or 2291161??
        {
            var α = Math.Truncate((Z - 1867216.25) / 36524.25);
            A = Z + 1 + α - Math.Truncate(α / 4);
        }
        var B = A + 1524;
        var C = Math.Truncate((B - 122.1) / 365.25);
        var D = Math.Truncate(365.25 * C);
        var E = Math.Truncate((B - D) / 30.6001);
        var days = B - D - Math.Truncate(30.6001 * E) + F;
        var months = E - 1;
        if (E >= 14)
        {
            months = E - 13;
        }
        var years = C - 4716;
        if (months <= 2)
        {
            years = C - 4715;
        }
        return new((int)years, (int)months, days);
    }
    private DateTime JDToGregorian(double JD, bool useDateTime)
    {
        var tuple = JDToGregorian(JD);
        return new DateTime(tuple.Item1, tuple.Item2, 1).AddDays(tuple.Item3 - 1);
    }

    private DateTime GetDateForMoonPhase(double k)
    {
        var T = k / 1236.85;
        var JDE = 2451550.09766 + 29.530588861 * k + 0.00015437 * T*T - 0.00000015 * T*T*T + 0.00000000073 * T*T*T*T;
        if (useLowPrecisionMoonPhaseCalculation)
        {
            return JDToGregorian(JDE, true);
        }
        var E = 1 - 0.002516 * T - 0.0000074 * T*T;
        var M = (2.5534 + 29.10535670 * k - 0.0000014 * T*T - 0.00000011 * T*T*T) * Math.PI / 180;
        var Mp = (201.5643 + 385.81693528 * k + 0.0107582 * T*T + 0.00001238 * T*T*T - 0.000000058 * T*T*T*T) * Math.PI / 180;
        var F = (160.7108 + 390.67050284 * k - 0.0016118 * T*T - 0.00000227 * T*T*T + 0.000000011 * T*T*T*T) * Math.PI / 180;
        var Ω = (124.7746 - 1.56375588 * k + 0.0020672 * T*T + 0.00000215 * T*T*T) * Math.PI / 180;

        var A1 = (299.77 + 0.107408 * k - 0.009173 * T*T) * Math.PI / 180;
        var A2 = (251.88 + 0.016321 * k) * Math.PI / 180;
        var A3 = (251.83 + 26.651886 * k) * Math.PI / 180;
        var A4 = (349.42 + 36.412478 * k) * Math.PI / 180;
        var A5 = (84.66 + 18.206239 * k) * Math.PI / 180;
        var A6 = (141.74 + 53.303771 * k) * Math.PI / 180;
        var A7 = (207.14 + 2.453732 * k) * Math.PI / 180;
        var A8 = (154.84 + 7.306860 * k) * Math.PI / 180;
        var A9 = (34.52 + 27.261239 * k) * Math.PI / 180;
        var A10 = (207.19 + 0.121824 * k) * Math.PI / 180;
        var A11 = (291.34 + 1.844379 * k) * Math.PI / 180;
        var A12 = (161.72 + 24.198154 * k) * Math.PI / 180;
        var A13 = (239.56 + 25.513099 * k) * Math.PI / 180;
        var A14 = (331.55 + 3.592518 * k) * Math.PI / 180;
        if (Math.Round(k) == k)
        {
            JDE += -0.4072 * Math.Sin(Mp) + 0.17241 * E * Math.Sin(M) + 0.01608 * Math.Sin(2 * Mp) + 0.01039 * Math.Sin(2 * F) + 0.00739 * E * Math.Sin(Mp - M) - 0.00514 * E * Math.Sin(Mp + M) + 0.00208 * E*E * Math.Sin(2 * M) - 0.00111 * Math.Sin(Mp - 2 * F) - 0.00057 * Math.Sin(Mp + 2 * F) + 0.00056 * E * Math.Sin(2 * Mp + M) - 0.00042 * Math.Sin(3 * Mp) + 0.00042 * E * Math.Sin(M + 2 * F) + 0.00038 * E * Math.Sin(M - 2 * F) - 0.00024 * E * Math.Sin(2 * Mp - M) - 0.00017 * Math.Sin(Ω) - 0.00007 * Math.Sin(Mp + 2 * M) + 0.00004 * Math.Sin(2 * Mp - 2 * F) + 0.00004 * Math.Sin(3 * M) + 0.00003 * Math.Sin(Mp + M - 2 * F) + 0.00003 * Math.Sin(2 * Mp + 2 * F) - 0.00003 * Math.Sin(Mp + M + 2 * F) + 0.00003 * Math.Sin(Mp - M + 2 * F) - 0.00002 * Math.Sin(Mp - M - 2 * F) - 0.00002 * Math.Sin(3 * Mp + M) + 0.00002 * Math.Sin(4 * Mp);
        }
        else if (Math.Ceiling(k) - .5 == k)
        {
            JDE += -0.40614 * Math.Sin(Mp) + 0.17302 * E * Math.Sin(M) + 0.01614 * Math.Sin(2 * Mp) + 0.01043 * Math.Sin(2 * F) + 0.00734 * E * Math.Sin(Mp - M) - 0.00515 * E * Math.Sin(Mp + M) + 0.00209 * E*E * Math.Sin(2 * M) - 0.00111 * Math.Sin(Mp - 2 * F) - 0.00057 * Math.Sin(Mp + 2 * F) + 0.00056 * E * Math.Sin(2 * Mp + M) - 0.00042 * Math.Sin(3 * Mp) + 0.00042 * E * Math.Sin(M + 2 * F) + 0.00038 * E * Math.Sin(M - 2 * F) - 0.00024 * E * Math.Sin(2 * Mp - M) - 0.00017 * Math.Sin(Ω) - 0.00007 * Math.Sin(Mp + 2 * M) + 0.00004 * Math.Sin(2 * Mp - 2 * F) + 0.00004 * Math.Sin(3 * M) + 0.00003 * Math.Sin(Mp + M - 2 * F) + 0.00003 * Math.Sin(2 * Mp + 2 * F) - 0.00003 * Math.Sin(Mp + M + 2 * F) + 0.00003 * Math.Sin(Mp - M + 2 * F) - 0.00002 * Math.Sin(Mp - M - 2 * F) - 0.00002 * Math.Sin(3 * Mp + M) + 0.00002 * Math.Sin(4 * Mp);
        }
        else
        {

        }
        JDE += (325 * Math.Sin(A1) + 165 * Math.Sin(A2) + 164 * Math.Sin(A3) + 126 * Math.Sin(A4) + 110 * Math.Sin(A5) + 62 * Math.Sin(A6) + 60 * Math.Sin(A7) + 56 * Math.Sin(A8) + 47 * Math.Sin(A9) + 42 * Math.Sin(A10) + 40 * Math.Sin(A11) + 37 * Math.Sin(A12) + 35 * Math.Sin(A13) + 23 * Math.Sin(A14)) / 1000000;
        return JDToGregorian(JDE, true);
    }
    private DateTime GetSummerSolsticeForGregorianYear(int year)
    {
        var Y = ((float)year - 2000) / 1000;
        var JDE0 = 2451716.56767 + 365241.62603 * Y + 0.00325 * Y*Y + 0.00888 * Y*Y*Y - 0.00030 * Y*Y*Y*Y;
        var T = (JDE0 - 2451545) / 36525;
        var W = 35999.373 * T - 2.47;
        var Δλ = 1 + 0.0334 * Math.Cos(W * Math.PI / 180) + 0.0007 * Math.Cos(W * Math.PI / 90);
        var S = ﻿485 * Math.Cos((324.96 + 1934.136 * T) * Math.PI / 180) + 45 * Math.Cos((247.54 + 29929.562 * T) * Math.PI / 180) + 203 * Math.Cos((337.23 + 32964.467 * T) * Math.PI / 180) + 44 * Math.Cos((325.15 + 31555.956 * T) * Math.PI / 180) + 199 * Math.Cos((342.08 + 20.186 * T) * Math.PI / 180) + 29 * Math.Cos((60.93 + 4443.417 * T) * Math.PI / 180) + 182 * Math.Cos((27.85 + 445267.112 * T) * Math.PI / 180) + 18 * Math.Cos((155.12 + 67555.328 * T) * Math.PI / 180) + 156 * Math.Cos((73.14 + 45036.886 * T) * Math.PI / 180) + 17 * Math.Cos((288.79 + 4562.452 * T) * Math.PI / 180) + 136 * Math.Cos((171.52 + 22518.443 * T) * Math.PI / 180) + 16 * Math.Cos((198.04 + 62894.029 * T) * Math.PI / 180) + 77 * Math.Cos((222.54 + 65928.934 * T) * Math.PI / 180) + 14 * Math.Cos((199.76 + 31436.921 * T) * Math.PI / 180) + 74 * Math.Cos((296.72 + 3034.906 * T) * Math.PI / 180) + 12 * Math.Cos((95.39 + 14577.848 * T) * Math.PI / 180) + 70 * Math.Cos((243.58 + 9037.513 * T) * Math.PI / 180) + 12 * Math.Cos((287.11 + 31931.756 * T) * Math.PI / 180) + 58 * Math.Cos((119.81 + 33718.147 * T) * Math.PI / 180) + 12 * Math.Cos((320.81 + 34777.259 * T) * Math.PI / 180) + 52 * Math.Cos((297.17 + 150.678 * T) * Math.PI / 180) + 9 * Math.Cos((227.73 + 1222.114 * T) * Math.PI / 180) + 50 * Math.Cos((21.02 + 2281.226 * T) * Math.PI / 180) + 8 * Math.Cos((15.45 + 16859.074 * T) * Math.PI / 180);
        var JDE = JDE0 + (0.00001 * S) / Δλ;
        var dateTriplet = JDToGregorian(JDE);
        return new DateTime(dateTriplet.Item1, dateTriplet.Item2, 1).AddDays(dateTriplet.Item3 - 1);
    }
    private DateTime GetClosestMoonPhase(DateTime dateTime, bool isForward = true, double phase = 0)
    {
        return GetClosestMoonPhase(dateTime, out var a, isForward, phase);
    }
    private DateTime GetClosestMoonPhase(DateTime dateTime, out double finalK, bool isForward = true, double phase = 0)
    {
        var k = (dateTime.Year - 2000) * 12.3685 + dateTime.Month;
        if (k > 0)
        {
            k = Math.Ceiling(k);
        }
        else
        {
            k = Math.Floor(k);
        }
        k += phase;
        var kMoon = GetDateForMoonPhase(k);
        if ((dateTime - kMoon).TotalDays < 30) // less than maximum cycle length difference
        {
            goto isCloseEnough;
        }
        k += Math.Floor((dateTime - kMoon).TotalDays / 30) * (dateTime > kMoon ? 1 : -1); // minimum cycles off
        kMoon = GetDateForMoonPhase(k);
        while ((dateTime - kMoon).TotalDays >= 30) // just to make sure, since I got no clue if my logic is right
        {
            k += (dateTime > kMoon ? 1 : -1);
            kMoon = GetDateForMoonPhase(k);
        }

    isCloseEnough:
        DateTime[] moons = new DateTime[3] { kMoon,
        GetDateForMoonPhase(k - 1),
        GetDateForMoonPhase(k + 1) };

        var moon = moons.Where(element => isForward ? (element > dateTime) : (element < dateTime)).OrderBy(element => Math.Max((element - dateTime).TotalDays, (dateTime - element).TotalDays)).First();
        finalK = Array.IndexOf(moons, moon) switch
        {
            0 => k,
            1 => k - 1,
            _ => k + 1
        };
        return moon;
    }
    private DateTime GetClosestSummerSolstice(DateTime dateTime, bool isForward = true)
    {
        return GetClosestSummerSolstice(dateTime, out var finalYear, isForward);
    }
    private DateTime GetClosestSummerSolstice(DateTime dateTime, out int finalYear, bool isForward = true)
    {
        DateTime[] solstices = new DateTime[3] { GetSummerSolsticeForGregorianYear(dateTime.Year),
        GetSummerSolsticeForGregorianYear(dateTime.Year - 1),
        GetSummerSolsticeForGregorianYear(dateTime.Year + 1) };

        var solstice = solstices.Where(element => isForward ? (element > dateTime) : (element < dateTime)).OrderBy(element => Math.Max((element - dateTime).TotalDays, (dateTime - element).TotalDays)).First();
        finalYear = Array.IndexOf(solstices, solstice) switch
        {
            0 => dateTime.Year,
            1 => dateTime.Year - 1,
            _ => dateTime.Year + 1
        };
        return solstice;
    }
}
